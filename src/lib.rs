use proc_macro::TokenStream;
use quote::quote;
use syn::{
    Attribute, Data, DeriveInput, Fields, Ident, Path, Visibility, parse::Parser,
    parse_macro_input, parse_quote, punctuated::Punctuated, token::Comma,
};

/// An attribute macro that automatically extends a configuration struct
/// to make it executable through Lua scripts.
///
/// # Overview
///
/// `#[tomlua_config]` is used to annotate a configuration struct that should be
/// script-driven via Lua. The macro automatically:
///
/// - Appends a `scripts: Vec<tomlua::Script>` field to the struct.
/// - Ensures that the struct derives the `TomluaExecute` trait (required for execution).
/// - Provides a bridge between Rust data and Lua scripts, allowing you to:
///   - Execute individual or all configured scripts.
///   - Inject struct fields as Lua globals.
///   - Mutate Rust data based on Lua script results.
///
/// This macro is intended for use in tandem with the [`tomlua`](https://crates.io/crates/tomlua)
/// crate, which provides the `Script` type and execution logic.
///
/// # Example
///
/// ```rust
/// use tomlua::tomlua_config;
/// use serde::{Serialize, Deserialize};
///
/// #[tomlua_config]
/// #[derive(Serialize, Deserialize)]
/// struct MyConfig {
///     name: String,
///     toggle: bool,
/// }
///
/// fn main() {
///     // Load configuration from TOML.
///     let cfg_str = std::fs::read_to_string("example_config.toml").unwrap();
///     let mut cfg: MyConfig = toml::from_str(&cfg_str).unwrap();
///
///     // Execute a specific Lua script by name.
///     cfg.update(cfg.execute_script("toggle_script").unwrap()).unwrap();
///
///     // Save updated configuration.
///     let cfg_str = toml::to_string_pretty(&cfg).unwrap();
///     std::fs::write("example_config.toml", cfg_str).unwrap();
/// }
/// ```
///
/// # Generated Fields
///
/// When applied, this macro **always adds** the following field to your struct:
///
/// ```rust,ignore
/// pub scripts: Vec<tomlua::Script>
/// ```
///
/// This field holds all scripts defined in your configuration, which may be either
/// inline or path-based. Each script is executed in a Lua VM with your struct’s fields
/// available as global variables.
///
/// # Limitations
///
/// - Can only be applied to **named structs** (not tuples or enums).
/// - Existing `#[derive(...)]` attributes are extended automatically with
///   `TomluaExecute`. If no derive is present, one is added.
/// - The macro will emit a compile-time error if applied to unsupported data types.
///
/// # See Also
///
/// - [`TomluaExecute`] — the trait that implements the runtime logic for
///   executing and updating your configuration.
/// - [`tomlua::Script`] — represents an individual Lua script (inline or path-based).
///
/// # Errors
///
/// Compilation fails if:
/// - The macro is applied to a non-struct item.
/// - The struct has unnamed fields (tuple structs are unsupported).
///
/// # Generated Implementation
///
/// This macro does **not** implement logic directly — it simply modifies your struct
/// and derives `TomluaExecute`, which provides:
///
/// - `execute_script(&self, name: &str)`
/// - `execute_all(&self)`
/// - `update(&mut self, lua: mlua::Lua)`
///
/// These methods are auto-generated by the `TomluaExecute` derive.
///
/// ---
#[proc_macro_attribute]
pub fn tomlua_config(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as DeriveInput);
    let struct_name: &Ident = &input.ident;
    let vis: &Visibility = &input.vis;

    let data = match &input.data {
        Data::Struct(s) => s,
        _ => {
            return syn::Error::new_spanned(
                input,
                "#[tomlua_config] attribute can only be used on structs",
            )
            .to_compile_error()
            .into();
        }
    };

    let mut fields = match &data.fields {
        Fields::Named(named) => named.named.clone(),
        _ => {
            return syn::Error::new_spanned(
                input,
                "#[tomlua_config] attribute does not support unnamed fields",
            )
            .into_compile_error()
            .into();
        }
    };

    fields.push(
        syn::Field::parse_named
            .parse2(quote! { pub scripts: ::std::vec::Vec<::tomlua::Script> })
            .unwrap(),
    );

    let mut attrs: Vec<Attribute> = input.attrs.clone();
    let mut derive_found = false;
    let mut new_attrs: Vec<Attribute> = Vec::new();
    for attr in &mut attrs {
        if attr.path().is_ident("derive") {
            derive_found = true;
            let nested: Punctuated<Path, Comma> = attr
                .parse_args_with(Punctuated::<Path, Comma>::parse_terminated)
                .unwrap_or_default();

            let mut new_nested = nested.clone();
            new_nested.push(parse_quote!(TomluaExecute));

            let new_attr: Attribute = parse_quote!(#[derive(#new_nested)]);
            new_attrs.push(new_attr);
        } else {
            new_attrs.push(attr.clone());
        }
    }

    if !derive_found {
        new_attrs.push(parse_quote!(#[derive(TomluaExecute)]))
    }

    let expanded = quote! {
        use ::tomlua::Script;

        #(#new_attrs)*
        #vis struct #struct_name {
            #fields
        }
    };

    expanded.into()
}

/// Automatically implements Lua script execution capabilities for a TOML-backed configuration struct.
///
/// The `TomluaExecute` derive macro enables a struct to:
/// 1. **Inject its fields as global Lua variables** before running a script.
/// 2. **Execute one or all Lua scripts** defined in the configuration.
/// 3. **Synchronize modified values** back into the Rust struct after script execution.
///
/// This derive macro is intended to be used together with the [`#[tomlua_config]`](crate::tomlua_config)
/// attribute macro, which automatically injects a `Vec<Script>` field into the struct and derives this
/// trait if necessary.
///
/// # Generated Methods
///
/// The macro expands into several helper methods that provide a complete Lua execution pipeline:
///
/// - `fn extract_lua_code(script: &Script) -> Result<String, String>`  
///   Resolves the Lua code to execute. Prefers `inline` script definitions over `path`-based ones.
///   Returns an error if neither is found.
///
/// - `pub fn execute_script(&self, script_name: &str) -> Result<Lua, String>`  
///   Executes a single Lua script by its name. Injects all struct fields into the Lua global scope.
///   Returns the `mlua::Lua` runtime for further inspection or state extraction.
///
/// - `pub fn execute_all(&self) -> Result<Lua, String>`  
///   Executes **all** scripts in the order they appear in the configuration.  
///   Useful for chained or dependent script execution.
///
/// - `pub fn update(&mut self, lua: Lua) -> Result<(), String>`  
///   Updates the struct fields by reading back their values from the Lua runtime’s global scope.
///   This enables two-way data flow between Rust and Lua.
///
/// # Example
///
/// ```rust
/// use tomlua::TomluaExecute;
///
/// #[derive(TomluaExecute)]
/// struct MyConfig {
///     name: String,
///     toggle: bool,
///     scripts: Vec<tomlua::Script>,
/// }
///
/// // Load, execute, and update
/// fn run(mut cfg: MyConfig) {
///     let lua = cfg.execute_script("toggle_handler").unwrap();
///     cfg.update(lua).unwrap();
/// }
/// ```
///
/// # Errors
///
/// - Fails if:
///   - The specified script does not exist in `scripts`.
///   - The `inline` and `path` fields are both missing or unreadable.
///   - A Lua runtime or global variable injection fails.
///
/// # Notes
///
/// - If both `inline` and `path` are present, `inline` takes precedence.
/// - All struct fields must implement `Clone` and `Deserialize` for data injection and retrieval.
/// - This macro is built around the [`mlua`](https://docs.rs/mlua) crate.
///
/// # See Also
///
/// - [`#[tomlua_config]`](crate::tomlua_config) – attribute macro that automatically derives `TomluaExecute`
///   and adds a `scripts` field.
/// - [`Script`](crate::Script) – represents a single executable Lua script.
#[proc_macro_derive(TomluaExecute)]
pub fn tomula_execute_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;

    let fields = if let syn::Data::Struct(ref data) = input.data {
        if let syn::Fields::Named(ref named) = data.fields {
            named.named.iter().map(|f| &f.ident).collect::<Vec<_>>()
        } else {
            vec![]
        }
    } else {
        vec![]
    };

    let expanded = quote! {
        use ::mlua::Lua;
        impl #name {
            fn extract_lua_code(script: &Script) -> Result<String, ::tomlua::error::Error> {
                match &script.inline() {
                    Some(code) if !code.is_empty() => return Ok(code.to_string()),
                    _ => {},
                }
                match &script.path() {
                    Some(p) => {
                        return Ok(std::fs::read_to_string(p)?)
                    },
                    _ => {},
                }
                Err(::tomlua::error::Error::EmptyScript(script.name().to_string()))
            }

            pub fn execute_script(&self, script_name: &str) -> Result<Lua, ::tomlua::error::Error> {
                let lua = Lua::new();
                let globals = lua.globals();
                #(globals.set(
                    stringify!(#fields),
                    self.#fields.clone()
                )?;)*

                if let Some(script) = self.scripts.iter().find(|s| s.name() == script_name) {
                    script.validate()?;
                    let lua_script_str = #name::extract_lua_code(&script)?;
                    lua.load(lua_script_str).exec()
                        .map_err(|error| {
                            let error = ::tomlua::error::lua_error_message(&error);
                            ::tomlua::error::Error::LuaRunTimeError { error, script: script.name().to_string() }
                        })?;
                }
                Ok(lua)
            }

            pub fn execute_all(&self) -> Result<Lua, ::tomlua::error::Error> {
                let lua = Lua::new();
                let globals = lua.globals();
                #(globals.set(
                    stringify!(#fields),
                    self.#fields.clone()
                )?;)*

                for script in &self.scripts {
                    script.validate()?;
                    let lua_script_str = #name::extract_lua_code(&script)?;
                    lua.load(lua_script_str).exec()
                        .map_err(|error| {
                            let error = ::tomlua::error::lua_error_message(&error);
                            ::tomlua::error::Error::LuaRunTimeError { error, script: script.name().to_string() }
                        })?;
                }
                Ok(lua)
            }

            pub fn update(&mut self, lua: &Lua) -> Result<(), ::tomlua::error::Error> {
                let globals = lua.globals();

                #(self.#fields = globals.get::<_>(stringify!(#fields))?;)*

                Ok(())
            }
        }
    };

    expanded.into()
}
